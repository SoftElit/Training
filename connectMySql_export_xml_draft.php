<?php
/*
Реализовать функцию exportXml($a, $b). $a – путь к xml файлу вида (структура файла приведена ниже), $b – код рубрики. 
Результат ее выполнения: выбрать из БД товары (и их характеристики, необходимые для формирования файла) выходящие в рубрику $b 
или в любую из всех вложенных в нее рубрик, сохранить результат в файл $a.
*/

//Функция экспорта из БД MySQL в XML-файл товаров выбранных разделов. $a – путь к xml-файлу ('target.xml'), $b – код раздела.
function exportXml($a, $b)
{

	//Подключаем скрипт подключения к серверу БД
	require_once "connectMySql.php";

	//Проверяем подключение к серверу БД и отправляем SQL запрос

	if(mysqli_connect_errno()) {
		echo mysqli_connect_error();
	} else {

		$result = mysqli_query(
		$connect,
		"SELECT a_product.id, a_product.код AS `Код`, a_product.название AS `Название`, a_price.`тип цены` AS `Тип`, a_price.`цена` AS `Цена`, a_property.`свойство` AS `Свойства`, a_property.`значение свойства`, a_category.`название`AS `Раздел`, a_category.id AS `код рубрики`
		FROM a_product 
		INNER JOIN a_price ON название = a_price.товар
		INNER JOIN a_property ON a_product.название = a_property.товар
		INNER JOIN a_category ON a_product.код = a_category.код
		;");

	};

	//Создание DOM-документа
	$dom = new DOMDocument('1.0', 'windows-1251'); //создал дескриптор на новый DOM-документ (объект)
	$dom->formatOutput = True; //Форматирует вывод, добавляя отступы и дополнительные пробелы. Не работает, если документ был загружен с включённым параметром preserveWhitespace. https://www.php.net/manual/ru/class.domdocument.php

	//Создание корневого элемента <ТОВАРЫ>
	$root = $dom->createElement("Товары"); //создаем корневой элемент
	$dom->appendChild($root); //присоединяем элемент к корню документа

	//=========================================================================================================
			//Функция создания элементов/узлов второго уровня (дочерние по отношению к <Товар>)
			//(на входе: корень ($dom), узел 1 уровня (<Товары>, $node), Имя узла ($tempNameElement), Текстовое содержимое узла ($tempCreate = NULL), Имя атрибута ($tempSetNameAttribute = NULL), Значение атрибута ($tempSetAttribute = NULL))
			function addChild2($dom, $node, $tempNameElement, $tempCreate = NULL, $tempSetNameAttribute = NULL, $tempSetAttribute = NULL)
			{
				$child = $dom->createElement($tempNameElement); //создали <элемент>
				$node->appendChild($child); //добавили <элемент> к элементу <Товар> в качестве дочернего
				
				if($tempCreate !== NULL) {
					$child->appendChild($dom->createTextNode($tempCreate)); //(вывели текст в элементе <>...</>) создали дочерний Текстовый узел для текущего узла.
				}
				
				if($tempSetNameAttribute != NULL && $tempSetAttribute != NULL) {
					$child->setAttribute($tempSetNameAttribute,$tempSetAttribute); //присваиваем атрибут "тип цены" элементу <Цена>
				}
				
				return $child;
			};
	//=========================================================================================================

	//=========================================================================================================
			//Функция создания элементов/узлов третьего уровня 
			//(на входе: корень ($dom), узел 1 уровня (<Товары>, $node), родительский узел ($child), Имя узла ($tempNameElement), Текстовое содержимое узла ($tempCreate = NULL), Имя атрибута ($tempSetNameAttribute = NULL), Значение атрибута ($tempSetAttribute = NULL))
			function addChild3($dom, $node, $child, $tempNameElement, $tempCreate = NULL, $tempSetNameAttribute = NULL, $tempSetAttribute = NULL)
			{
				$child2 = $dom->createElement($tempNameElement); //создали <элемент>
				$child->appendChild($child2); //добавили <элемент> к элементу <...> в качестве дочернего
				
				if($tempCreate !== NULL) {
				$child2->appendChild($dom->createTextNode($tempCreate)); //(вывели значение элемента в теге <>...</>) создали дочерний Текстовый узел для текущего узла
				}
				
				if($tempSetNameAttribute != NULL && $tempSetAttribute != NULL) {
				$child2->setAttribute($tempSetNameAttribute,$tempSetAttribute); //присваиваем атрибут (наименование="значение") текущему дочернему элементу
				}
				
				return $child2;
			};
	//=========================================================================================================

	//=========================================================================================================
	//Функция проверки элементов на дубли
	/* Входные параметры: 
	1) что проверяем на дубли ($childKey = ключ текущего элемента массива $row)
	2) в каком массиве узлов ($checkMassive = $elements[$key])
	3) Массив полученных из БД MySQL записей ($row)
	*/
	function checkDuplicate2($childKey, $checkMassive, $row)
	{
		//Перебираем в массиве узлов ($elements[$key]) детей найденного в массиве записей из БД MySQL ($rows[]) узла <ТОВАР>
		foreach($checkMassive->childNodes as $childN) { //на каждой итерации цикла проверяем один очередной дочерний узел узла <Товар> (например: Товар->Цена или Товар->Свойства или Товар->Разделы)

			//Проверка на дубли по наименованию узла
				switch ($childKey) {
					case 'Цена':
						if($childN->getAttribute('Тип') == $row['Тип']) { //проверяем атрибут 'Тип' узла <Цена>
							$add = FALSE; //Индикатор записи (если записывали в массив ранее)
							break 2;	//выходим из switch и из foreach. break прерывает выполнение текущей структуры for, foreach, while, do-while или switch. break принимает необязательный числовой аргумент, который сообщает какое количество вложенных структур необходимо прервать. Значение по умолчанию 1, только ближайшая структура будет прервана.
						} else {
							$add = TRUE;
							break; //выходим только из switch (так как требуется продолжать проверку по всем детям текущего узла, пока не будет совпадение или конец списка)
						}

					case 'Свойства':
						if('Свойства' == $childN->nodeName) {
							$add = FALSE; //Индикатор записи (если записывали в массив ранее)
							break 2;	//выходим из switch и из foreach. break прерывает выполнение текущей структуры for, foreach, while, do-while или switch. break принимает необязательный числовой аргумент, который сообщает какое количество вложенных структур необходимо прервать. Значение по умолчанию 1, только ближайшая структура будет прервана.
						} else {
							$add = TRUE;
							break; //выходим только из switch (так как требуется продолжать проверку по всем детям текущего узла, пока не будет совпадение или конец списка)
						}

					//case 'Разделы':
					case 'Раздел':
						if('Разделы' == $childN->nodeName) {
							$add = FALSE; //Индикатор записи (если записывали в массив ранее)
							break 2;	//выходим из switch и из foreach. break прерывает выполнение текущей структуры for, foreach, while, do-while или switch. break принимает необязательный числовой аргумент, который сообщает какое количество вложенных структур необходимо прервать. Значение по умолчанию 1, только ближайшая структура будет прервана.
						} else {
							$add = TRUE;
							break; //выходим только из switch (так как требуется продолжать проверку по всем детям текущего узла, пока не будет совпадение или конец списка)
						}
				}
		}
		return $add;
	}

	//=========================================================================================================

	//=========================================================================================================
	//Функция проверки элементов на дубли
	/* Входные параметры: 
	1) что проверяем на дубли ($childKey = ключ текущего элемента массива $row)
	2) что проверяем на дубли ($childValue = значение текущего элемента массива $row)
	3) в каком массиве узлов ($checkMassive = $elements[$key]), 
	4) Массив полученных из БД MySQL записей ($row)
	*/
	function checkDuplicate3($childKey, $childValue, $checkMassive, $row)
	{
		//Перебираем в массиве узлов ($elements[$key]) детей найденного в массиве записей из БД MySQL ($rows[]) узла <ТОВАР>
		foreach($checkMassive->childNodes as $childN) { //на каждой итерации цикла проверяем один очередной дочерний узел узла <Товар> (например: Товар->Цена или Товар->Свойства или Товар->Разделы)

			foreach($childN->childNodes as $childValue3) { //<Разделы> -> <Раздел> или <Свойства> -> <Плотность>

				switch ($childKey) {
					case 'Раздел':
						if($childValue == $childValue3->nodeValue) { //$childValue3->nodeValue -это значение (содержимое) узла <Раздел>
							$add = FALSE; //Индикатор записи (если записывали в массив ранее)
							break 3;	//выходим из switch и из обоих foreach. break прерывает выполнение текущей структуры for, foreach, while, do-while или switch. break принимает необязательный числовой аргумент, который сообщает какое количество вложенных структур необходимо прервать. Значение по умолчанию 1, только ближайшая структура будет прервана.
						} else {
							$add = TRUE;
							break; //выходим только из switch (так как требуется продолжать проверку по всем детям текущего узла, пока не будет совпадение или конец списка)
						}

					case 'Свойства':
						if($childValue == $childValue3->nodeName && $row['значение свойства'] == $childValue3->nodeValue) { //$childValue3->nodeName -это наименование (ключ) дочернего узла <Свойства> (<Плотность> или <Белизна> или <Формат> или <Тип>), а $childValue3->nodeValue -значение (содержимое) этого дочернего узла
							$add = FALSE; //Индикатор записи (если записывали в массив ранее)
							break 3;	//выходим из switch и из обоих foreach. break прерывает выполнение текущей структуры for, foreach, while, do-while или switch. break принимает необязательный числовой аргумент, который сообщает какое количество вложенных структур необходимо прервать. Значение по умолчанию 1, только ближайшая структура будет прервана.
						} else {
							$add = TRUE;
							break; //выходим только из switch (так как требуется продолжать проверку по всем детям текущего узла, пока не будет совпадение или конец списка)
						}
				}
			}
		}
		return $add;
	}

	//=========================================================================================================


		//ЛОГИКА. Получаем записи из таблиц и формируем из них дерево DOM
			$i = 0; //инициализация индекса Массива $rows[$i] (полученных из БД MySQL записей)
			$elements = []; //Массив $node (узлов DOM)
			$rows = []; //Массив полученных из БД MySQL записей

	while($row = $result->fetch_assoc()) { //получение записей из таблиц БД MySQL

		//Проверка выбранного раздела для формирования выборки из БД
		//if($row['Раздел'] == $b) {
		if($row['код рубрики'] == $b || $row['Раздел'] == $b) {
		
		//Если такой ID пока не сохранён в Массиве записей из БД MySQL (избавляемся от дублей по ID)
		if(FALSE === ($key = array_search($row['id'], array_column($rows, 'id')))) {	//$key - индексстроки в Массиве записей из БД MySQL ($rows[]) проверяем на FALSE, потому что array_search возвращает FALSE или ключ найденного элемента
																						
			$rows[$i] = $row; //Массив записей из БД MySQL
			
			//Создаем элемент <Товар>
			$node = $dom->createElement('Товар'); //создаем элемент <Товар> (дочерний элемент корневого элемента "Товары")
			$root->appendChild($node); //и добавляем его в корневой элемент <Товары>

			$elements[$i] = $node; //Массив узлов
			
			//Получаем наименования для дочерних узлов узла <Товар> из функции fetch_assoc() в вышестоящем цикле while
			
			//АТРИБУТЫ <ТОВАРА>
			$elements[$i]->setAttribute("Код", $rows[$i]['Код']); //присваиваем атрибуты 'код' и 'название' элементу <Товар>
			$elements[$i]->setAttribute("Название", $rows[$i]['Название']); //присваиваем атрибуты 'код' и 'название' элементу <Товар>

			//<ЦЕНА> - узел 1 уровня
			addChild2($dom, $elements[$i], 'Цена', $row['Цена'], 'Тип', $row['Тип']);		
			
			$i++; //увеличиваем индекс
			
		}else{	//Если <ТОВАР> есть в Массиве записей из БД MySQL ($rows[]) (и, соответственно, есть $key с ключом его ID, а также есть соответствующий в Массиве узлов ($elements[]))- проверяем дочерние узлы на дубли и проводим запись

			foreach ($row as $childKey => $childValue) { //на каждой итерации цикла проверяем один очередной элемент записи из БД MySQL (например: $row['Цена'] или $row['Свойства'] или $row['Раздел'])

				$add = checkDuplicate2($childKey, $elements[$key], $row);
				
				//Результат проверки == FALSE или TRUE для узлов 2-го уровня(<ЦЕНА> или <Свойства> или <Раздел>)
				if($add === TRUE) {

					if($childKey == 'Цена') {
						addChild2($dom, $elements[$key], $childKey, $childValue, 'Тип', $row['Тип']); //то записываем в найденный в Массиве узлов ($elements[]) узел <ТОВАР> - новый узел <ЦЕНА>
					}

					if($childKey == 'Раздел') {
						$childR = addChild2($dom, $elements[$key], 'Разделы'); //то записываем в найденный в Массиве узлов ($elements[]) узел <ТОВАР> - новый узел <Разделы>
					}
					
					if($childKey == 'Свойства') {
						$childP = addChild2($dom, $elements[$key], 'Свойства'); //то записываем в найденный в Массиве узлов ($elements[]) узел <ТОВАР> - новый узел <Свойства>
					}
				}

				//Результат проверки == FALSE или TRUE для узлов 3-го уровня(<Плотность> или <Белизна> или <Формат> или <Тип> или <Раздел>)
				if($childKey == 'Раздел') {
					$add3 = checkDuplicate3($childKey, $childValue, $elements[$key], $row);
					
					if($add3 === TRUE) {
						$child2 = addChild3($dom, $elements[$key], $childR, $childKey, $childValue);
					}
				}

				if($childKey == 'Свойства') {
					if($childValue == 'Белизна ЕдИзм=%') { //костыль до исправления в БД и скрипте импорта
						$childValue = 'Белизна';
					}
					
					$add4 = checkDuplicate3($childKey, $childValue, $elements[$key], $row); //в параметрах ($childKey = 'Свойства', $childValue = 'Плотность', $elements[$key] = найденный узел, $row = текущая строка из БД)

					if($add4 === TRUE) {
						$child2 = addChild3($dom, $elements[$key], $childP, $childValue, $row['значение свойства']); //в параметрах ($dom, $elements[$key], родительский узел <Свойства>, Имя узла = $childValue (Плотность или другое свойство), $row['значение свойства'])
					}
				}

			} //end foreach
		}
	};

/*
			//ДЛЯ ОТЛАДКИ - УДАЛИТЬ !!!
			foreach ($root->childNodes as $q) {
				echo 'NAME ROOT_CHILD = ' . $q->nodeName . '<br>';
				foreach ($q->childNodes as $w) {
					echo '___NAME TOVAR_CHILD = ' . $w->nodeName . '<br>';
				}
			}
			
			echo '<br><br><br>';
		if(gettype($b) !== 'string') {
		
			//Сортировка узлов для корректного вывода (требуется при выводе полной выборки из БД)
			foreach ($root->childNodes as $q) {
				if ($q->lastChild->nodeName == $q->firstChild->nodeName) {
					//public DOMNode::replaceChild ( DOMNode $node , DOMNode $child ) : DOMNode|false. Возвращает старый узел или false в случае возникновения ошибки.
					$w = $q->replaceChild($q->lastChild, $q->childNodes[1]); //функция DOMNode::replaceChild заменяет дочерний узел child новым узлом. Если узел node уже является дочерним, то он не будет добавлен во второй раз. Если замена прошла успешно, то будет возвращён старый (заменяемый) узел.
					$q->appendChild($w);
					$w = $q->replaceChild($q->lastChild, $q->childNodes[2]);
					$q->appendChild($w);
				}
			}
		}

			//ДЛЯ ОТЛАДКИ - УДАЛИТЬ !!!
			foreach ($root->childNodes as $q) {
				echo 'NAME ROOT_CHILD = ' . $q->nodeName . '<br>';
				foreach ($q->childNodes as $w) {
					echo '___NAME TOVAR_CHILD = ' . $w->nodeName . '<br>';
				}
			}
*/

	}

		//$dom->save( 'target.xml' ); //сохранение объекта (DOM-документа) в файл.
		$dom->save($a); //сохранение объекта (DOM-документа) в файл.

	//Закрываем подключение к серверу БД
	mysqli_close($connect);

};

//Вызов функции
$a = 'target.xml';
//$b = 'Бумага'; //выборка по наименованию Раздела (проверка на строке 179)
$b = 42; //выборка по коду Раздела (проверка на строке 179)
$run = exportXml($a, $b);
