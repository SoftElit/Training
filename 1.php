<?php
/*
1.1. Реализовать функцию findSimple ($a, $b). $a и $b – целые положительные числа. Результат ее выполнение: массив простых чисел от $a до $b.
*/

$arrayPrimeNumbers[] = 0;

//Функция поиска в массиве положительных чисел (заданные параметры $a и $b – целые положительные числа, границы массива)
function findSimple($a, $b)
{
	//Функция проверки одного числа на "простое"
	function PrimeNumbers($i)
	{
		//1 - не является простым числом
		if ($i == 1) {
			return false;
		//2 - простое число
		} elseif ($i == 2) {
			return $i;
		} else {
				//перебираем возможные делители от 2 до середины $b
				for($d = 2; $d <= $i / 2; $d++) { 

					//если разделилось нацело не на себя
					if (($i % $d == 0) && ($i != $d)) {
						//$f = 'false'; //метка для составного числа
						//исправил на булевое значение
						$f = true; //метка для составного числа
					};
				};
				/* Устранение "замечания 1)", исправил на булевое значение (с булевым значением false условие работало некорректно, 
				т.к. $f могла быть не инициализирована) */
				//if ($f != 'false') {
				if ($f != true) {
					return $i;
				} else {
					//исправил замечание "Судя по всему, функция PrimeNumbers не всегда что-то возвращает", но зачем нам этот блок ?
					return false;
				}
		}
	}
		//Перебираем значения исходного массива целых положительных чисел
		for($i = $a; $i <= $b; $i++) {
			//Вызываем функцию PrimeNumbers и если возвращенное значение не равно false, сохраняем его в массив
			PrimeNumbers($i) != false ? $arrayPrimeNumbers[] = PrimeNumbers($i) : '';
		};
	return $arrayPrimeNumbers;
};

$result = findSimple(1, 100); //массив простых чисел от $a до $b (задаём в параметрах $a и $b – целые положительные числа начала и конца массива)
print_r($result);
echo '<br>';


/*
1.2. Реализовать функцию createTrapeze($a). $a – массив положительных чисел, количество элементов кратно 3. 
Результат ее выполнение: двумерный массив (массив состоящий из ассоциативных массива с ключами a, b, c). 
Пример для входных массива [1, 2, 3, 4, 5, 6] результат [[‘a’=>1,’b’=>2,’с’=>3],[‘a’=>4,’b’=>5 ,’c’=>6]].
*/

//Функция формирования двумерного массива из одномерного
$arrayPositiveNumbers = [1, 2, 3, 4, 5, 6];

function createTrapeze($a)
{
	$arrayTwoDimensional = ['a', 'b', 'c',]; //массив ключей для array_combine
	$b = array_chunk($a, 3); //разбиваем исходный массив на двумерный по 3 значения в каждом элементе
	
	//Проходим по элементам верхнего уровня и присваиваем элементам второго уровня новые ключи
	foreach($b as $value) {
		$c[] = array_combine($arrayTwoDimensional, $value);
	};
	return $c;
}

$result2 = createTrapeze($arrayPositiveNumbers);
echo '<br>';
print_r($result2);
echo '<br>';


/*
1.3. Реализовать функцию squareTrapeze($a). $a – массив результата выполнения функции createTrapeze(). 
Результат ее выполнение: в исходный массив для каждой тройки чисел добавляется дополнительный ключ s, 
содержащий результат расчета площади трапеции со сторонами a и b, и высотой c.
*/

//Функция вычисления площади трапеции (S = (a + b)) / 2 * h) по данным в массиве
function squareTrapeze($a)
{
	//В цикле вычисляем площадь каждой трапеции (элемента массива)
	foreach($a as $value) {
		$s[] = ($value['a'] + $value['b']) / 2 * $value['c'];
	};
	
	/* Устранение замечания "Можно сразу вернуть array_combine($s, $a) (не обязательно записывать результат в $c).
	Если $a будет пустым, то $s не будет объявлено." */
	//$c = array_combine($s, $a); //Меняем ключи у элементов верхнего уровня
	//return $c;
	return array_combine($s, $a); //Меняем ключи у элементов верхнего уровня
}

$result3 = squareTrapeze($result2);
$result2 = $result3;
echo '<br>';
print_r($result2);
echo '<br>';


/*
1.4. Реализовать функцию getSizeForLimit($a, $b). $a – массив результата выполнения функции squareTrapeze(), $b – максимальная площадь. 
Результат ее выполнение: массив размеров трапеции с максимальной площадью, но меньше или равной $b.
*/

//Функция формирования массива размеров трапеции с максимальной площадью, но меньше или равной заданной в $b
function getSizeForLimit($a, $b)
{
	foreach($a as $key => $value) {
		$maxS[] = $key;
	};
	
	/* Функции сортировки массива. $sort = SORT_ASC или SORT_DESC задаёт направление сортировки. 
	Оператор сравнения <=> с PHP 7.0 возвращает в зависимости от того, какой оператор больше, -1 (левый больше), 0 (равны), или 1 (правый больше). */
	function arraySort($array, 	$sort = SORT_ASC)
	{
		usort($array, function ($a, $b) use ($sort)
		{
			return $sort == SORT_DESC ? ($b <=> $a) : ($a <=> $b);
		});
		return $array;
	};
	
	//Сортируем исходный массив в порядке убывания
	$maxS = arraySort($maxS, SORT_DESC);
	//Проверяем условие "площадь меньше или равна $b"
	for($i = 0; $i <= array_count_values($maxS); $i++) {
		if ($maxS[$i] <= $b) {
			return $a[$maxS[$i]];
		};
	};
};

$result4 = getSizeForLimit($result3, 26);
echo '<br>';
print_r($result4);
echo '<br>';


/*
1.5. Реализовать функцию getMin($a). $a – массив чисел. 
Результат ее выполнения: минимальное число в массиве (не используя функцию min, ключи массив может быть ассоциативный).
*/

//Функция поиска минимального числа в массиве
function getMin($a)
{
	/* Функции сортировки массива. $sort = SORT_ASC или SORT_DESC задаёт направление сортировки. 
	Оператор сравнения <=> с PHP 7.0 возвращает в зависимости от того, какой оператор больше, -1 (левый больше), 0 (равны), или 1 (правый больше). */
	
	/* Закоментировал функцию сортировки массива, так как она уже есть в этом файле. 
	Можно вынести в отдельный файл и просто её подключать в соответствующие скрипты или переименовать внутри этой функции. */
	/*
	function arraySort($array, 	$sort = SORT_ASC)
	{
		usort($array, function ($a, $b) use ($sort)
		{
			return $sort == SORT_DESC ? ($b <=> $a) : ($a <=> $b);
		});
		return $array;
	};
	*/
	
	//$arrayTemp = $a; //Сохраним исходный массив во временной переменной, чтобы не изменять его (нет в условиях задачи изменения массива)
	
	//Сортируем исходный массив в порядке возрастания
	$maxS = arraySort($a);
	
	//echo '<br>';
	//print_r($maxS); //Вывод в браузер отсортированного массива
	//echo '<br>';
	return $maxS[0];
}

$arrayIsxodny = [2, 0, 4, -48.2, -3, 126, 5, -33.5, 22.2];
$result5 = getMin($arrayIsxodny);
echo '<br>';
var_dump($result5);
echo '<br>';
//print_r($arrayIsxodny); //Вывод в браузер исходного массива
//echo '<br>';


/*
1.6. Реализовать функцию printTrapeze($a). $a – массив результата выполнения функции squareTrapeze(). 
Результат ее выполнение: вывод таблицы с размерами трапеций, строки с нечетной площадью трапеции отметить любым способом.
*/

//Функция вывода в браузер таблицы значений
function printTrapeze($a)
{
	foreach($a as $k => $val) {
		$key[] = $k;
		foreach($val as $v) {
			$value[] = $v;
		};
	};
	
	echo '<table border = "1">'; //Рисуем таблицу (размер бордюра)

	$cols = 4; //задаем количество столбцов
	$rows = 4; //задаем количество строк
	$tableHeadName = ['Площадь трапеции', 'основание a', 'основание b', 'высота h'];
	
	$i = 0; //Инициализируем счётчик для вывода элементов массива в цикле
	$j = 0; //Инициализируем счётчик для вывода элементов массива в цикле
	$k = 0; //Инициализируем счётчик для вывода элементов массива в цикле
	$c = $i + 1; //Инициализируем счётчик для вывода цвета

	for($tr = 1; $tr <= $rows; ++$tr)
	{
		if($tr == 1)
		{
			echo "<thead>";
			echo "<tr>"; //выводим строку
			for($td = 1; $td <= $cols; ++$td)
			{
				echo "<th style = 'background-color: yellow'>" . $tableHeadName[$k++] . "</th>"; //выводим ячейку с особым цветом фона (для первой строки - строки заголовков)
			}	
			echo "</tr>";
			echo "</thead>";
		} else {
			echo "<tbody>";
			echo '<tr';
			echo ($key[$c] % 2 != 0) ? ' style = \'background-color: grey\'>' : '>'; //выводим строку, если ключ-площадь нечётная, то фон серый
			for($td = 1; $td <= $cols; ++$td)
			{
				if($td == 1) {
				/* В элемент thead заключается строка заголовков. Для ячеек заголовок используется не элемент td, а th. 
				Элемент th выделяет заголовок жирным. А все остальные строки заключаются в tbody */
					echo "<th>" . (($i < array_count_values($key)) ? ($key[$i++]) : '') . "</th>";
				} else {
						echo "<td>" . $value[$j++] . "</td>"; //иначе выводим обычную ячейку (номер столбца в строке)
				};
			};
			echo "</tr>"; //закрываем строку
			echo "</tbody>";
		};
	};
		echo "<tfoot>";
			echo "<tr>";
				echo "<th colspan='10'>Примечания: таблица масштабируема через массивы</th>";
			echo "</tr>";
		echo "</tfoot>";

	echo '</table>';
};

echo '<br>';
$result6 = printTrapeze($result2);
echo '<br>';


/*
Реализовать абстрактный класс BaseMath содержащий 3 метода: exp1($a, $b, $c) и exp2($a, $b, $c),getValue(). 
Метода exp1 реализует расчет по формуле a*(b^c). Метода exp2 реализует расчет по формуле (a/b)^c. 
Метод getValue() возвращает результат расчета класса наследника.
*/

abstract class BaseMath
{	
	/* Устранение замечания "3) Класс BaseMath. В условии уже перечислены параметры, которые принимают методы exp1 и exp2. 
	Свои добавлять не желательно." */
	//function exp1($a, $b, $c, &$rezExp1)
	function exp1($a, $b, $c)
	{
		//$rezExp1 = $a * pow($b, $c);
		return $a * pow($b, $c);
	}
	
	//function exp2($a, $b, $c, &$rezExp2)
	function exp2($a, $b, $c)
	{
		//$rezExp2 = pow(($a / $b), $c);
		return pow(($a / $b), $c);
	}
	
	abstract public function getValue();
}

//В классе-наследнике расширяем метод getValue, $q передаём для получения результата расчётов
class F0 extends BaseMath
{
	public function getValue()
	{
	/* Устранение замечания "3) Класс BaseMath. В условии уже перечислены параметры, которые принимают методы exp1 и exp2. 
	Свои добавлять не желательно." */
		//parent::exp1 (2, 2, 2);
		//return $q;
		return parent::exp1 (2, 2, 2);
	}
}

/* Если указываем родительский класс, то функция получается универсальная. 
Если указываем класс-наследник, то для каждого класса нужно создавать свою вспомогательную функцию вывода в браузер. */
//function FprintRezultat(F0 $BaseMathChild)
function FprintRezultat(BaseMath $BaseMathChild)
{
	echo $BaseMathChild->getValue();
	echo '<br>';
}

$f0 = new F0();
FprintRezultat($f0);


/*
Реализовать класс F1 наследующий методы BaseMath, содержащий конструктор с параметрами ($a, $b, $c) и метод getValue(). 
Класс реализует расчет по формуле f=(a*(b^c)+(((a/c)^b)%3)^min(a,b,c)).
*/

class F1 extends BaseMath
{
	public $f;
	public function __construct($a, $b, $c)
	{
		/* Устранение замечания "4) Класс F1. Дабы не дублировать код, можно использовать родительские методы." */
		//$this->f = pow(($a * pow($b, $c) + (pow(($a / $b), $c)) % 3), min($a, $b, $c)); //f=(a*(b^c)+(((a/c)^b)%3)^min(a,b,c))
		$this->f = pow((parent::exp1 (2, 2, 2, $q) + (parent::exp2 (2, 2, 2, $q) % 3)), min($a, $b, $c)); //f=(a*(b^c)+(((a/c)^b)%3)^min(a,b,c))
	}
	
	public function getValue()
	{
		$this->f;
		return $this->f;
	}
}

$f1 = new F1(2, 2, 2);
FprintRezultat($f1);
